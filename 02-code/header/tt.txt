/* ../source/area.c */
double catchment_area(catchment *c, section *mouth, int direction, int max_steps, double step_size, int n_stream, path **streamline, bem_vectors *vectors);
/* ../source/boundary.c */
int boundary_loops(unsigned char *file);
boundary *create_boundary(int n);
boundary *destroy_boundary(boundary *b);
boundary *destroy_boundary_ignore_paths(boundary *b);
int num_points_in_zone(boundary *b);
void get_boundary(unsigned char *file, boundary *b);
void plot_boundary(boundary *b, unsigned char *file);
/* ../source/bsolve.c */
void make_boundary_voltage_vector(boundary *b, matrix *bvv);
void fill_boundary_voltage_vector(path *path_i, double *result);
void make_boundary_current_vector(boundary *b, matrix *V, matrix *J);
void make_bcv_no_KCL(boundary *b, matrix *V, matrix *J);
void make_bcv_use_KCL(boundary *b, matrix *V, matrix *J);
void make_boundary_vector(boundary *b, matrix *bvv, matrix *bcv);
double make_internal_voltage(boundary *b, matrix *bvv, matrix *bcv, coordinates P, matrix *vgv, matrix *cgv);
void make_internal_grad_voltage(boundary *b, matrix *bvv, matrix *bcv, coordinates P, co_matrix *co_vgv, co_matrix *co_cgv, coordinates Gv);
void make_internal_sec_grad_voltage(boundary *b, matrix *bvv, matrix *bcv, coordinates P, ten_matrix *ten_vgv, ten_matrix *ten_cgv, tensor Gv);
/* ../source/catchment.c */
int catchment_zones(unsigned char *file);
catchment *create_catchment(int zones, int paths);
catchment *destroy_catchment(catchment *c);
int max_points_in_any_zone(catchment *c);
void get_catchment(unsigned char *file, catchment *c);
void plot_catchment(catchment *c, unsigned char *file);
int check_each_zone(catchment *c, coordinates P);
int check_zone(boundary *b, coordinates P);
void reverse_zone(boundary *b);
void reverse_all_paths(boundary *b);
int distance_to_path(coordinates P, path *this_path, double *d, double *s, int *segment);
void mark_paths(boundary *b);
void mark_curve(boundary *b);
int find_orientation(path *this_path);
void find_limits(path *this_path, coordinates min, coordinates max);
int count_paths(boundary *b, int *outside_zone, int *inside_zone);
void show_curve(boundary **zones, int i);
void show_paths(boundary **zones, int i);
void check_each_path(catchment *c, coordinates P, double *d, double *s, int *segment, path **this_path);
/* ../source/co_matrix.c */
co_matrix *create_co_matrix(int rows, int columns);
void attach_co_matrix(co_matrix *x, int rows, int columns, coordinates *data);
co_matrix *destroy_co_matrix(co_matrix *x);
void check_co_matrix_index(co_matrix *x, int i, int j);
void check_co_invert(co_matrix *x);
void check_co_memory(co_matrix *x);
void check_co_multiply_shape(co_matrix *a, matrix *b);
void check_co_multiply_size(co_matrix *a, matrix *b, co_matrix *x);
int get_co_num_columns(co_matrix *x);
int get_co_num_rows(co_matrix *x);
coordinates *startof_co_matrix(co_matrix *x);
void put_co_matrix_element(co_matrix *x, int i, int j, coordinates value);
void get_co_matrix_element(co_matrix *x, int i, int j, coordinates value);
void put_block_co_matrix_element(co_matrix *x, int offset_i, int offset_j, int i, int j, coordinates value);
void get_block_co_matrix_element(co_matrix *x, int offset_i, int offset_j, int i, int j, coordinates value);
void multiply_co_matrix(co_matrix *a, matrix *b, co_matrix *x);
void multiply_co_element_row(co_matrix *a, matrix *b, int row_a, co_matrix *x);
void multiply_co_element_column(co_matrix *a, matrix *b, int row_a, int column_b, co_matrix *x);
/* ../source/file.c */
int put_buffer(int n, unsigned char *buffer, int offset, unsigned char *format, double value);
FILE *open_file(int use_path, char *file, char *mode);
int count_lines(int use_path, char *file);
int get_next_line(FILE *input, int n, unsigned char *buffer);
int get_next_line_verbose(FILE *input, int k, int n, unsigned char *buffer);
void put_next_line(FILE *output, unsigned char *buffer);
void catchment_path(int n, unsigned char *c_path);
void make_gpl_file(char *datafile, char *title, char *xrange, char *yrange);
void make_gpl2_file(char *datafile, char *title, char *xlabel, char *ylabel);
/* ../source/geometry.c */
void convert_PQ(coordinates Qa, coordinates Qb, coordinates P, double *x, double *y1, double *y2);
void rotate_to_PQ(double x, double y, coordinates Qa, coordinates Qb, coordinates R);
void double_rotate_to_PQ(double a, double b, double c, double d, coordinates Qa, coordinates Qb, tensor R);
double atan3(double y2, double y1, double x);
double atanv(coordinates Q1, coordinates Q2, coordinates P);
/* ../source/linear_sys.c */
void make_voltage_geometry_matrix(boundary *b, matrix *vgm);
void fill_voltage_geometry_matrix(int offset_i, int offset_j, path *path_i, path *path_j, matrix *vgm);
void make_current_geometry_matrix(boundary *b, matrix *cgm);
void fill_current_geometry_matrix(int offset_i, int offset_j, path *path_i, path *path_j, matrix *cgm);
void make_diagonal_matrix(boundary *b, matrix *dm);
void fill_diagonal_matrix(int offset_i, int offset_j, path *path_i, path *path_j, matrix *dm);
void empty_diagonal_matrix(int offset_i, int offset_j, path *path_i, path *path_j, matrix *dm);
void make_voltage_geometry_vector(coordinates P, boundary *b, matrix *vgv);
void fill_voltage_geometry_vector(coordinates P, int offset_j, path *path_j, matrix *vgv);
void make_current_geometry_vector(coordinates P, boundary *b, matrix *cgv);
void fill_current_geometry_vector(coordinates P, int offset_j, path *path_j, matrix *cgv);
void make_kcl_geometry_vector(boundary *b, matrix *kcl);
void fill_kcl_geometry_vector(int offset_j, path *path_j, matrix *kcl);
void make_co_voltage_geometry_vector(coordinates P, boundary *b, co_matrix *co_vgv);
void fill_co_voltage_geometry_vector(coordinates P, int offset_j, path *path_j, co_matrix *co_vgv);
void make_co_current_geometry_vector(coordinates P, boundary *b, co_matrix *co_cgv);
void fill_co_current_geometry_vector(coordinates P, int offset_j, path *path_j, co_matrix *co_cgv);
void make_ten_voltage_geometry_vector(coordinates P, boundary *b, ten_matrix *ten_vgv);
void fill_ten_voltage_geometry_vector(coordinates P, int offset_j, path *path_j, ten_matrix *ten_vgv);
void make_ten_current_geometry_vector(coordinates P, boundary *b, ten_matrix *ten_cgv);
void fill_ten_current_geometry_vector(coordinates P, int offset_j, path *path_j, ten_matrix *ten_cgv);
void p2c_2coeff(double v, double w, double *a0, double *a1);
void p2c_4coeff(double j, double k, double l, double m, double *a0, double *a1, double *a2, double *a3);
void p2c_2basis(double Vterm, double Wterm, double *A0, double *A1);
void p2c_4basis(double Jterm, double Kterm, double Lterm, double Mterm, double *A0, double *A1, double *A2, double *A3);
void p2c_2basis_co(coordinates Vterm, coordinates Wterm, coordinates A0, coordinates A1);
void p2c_4basis_co(coordinates Jterm, coordinates Kterm, coordinates Lterm, coordinates Mterm, coordinates A0, coordinates A1, coordinates A2, coordinates A3);
void p2c_2basis_ten(tensor Vterm, tensor Wterm, tensor A0, tensor A1);
void p2c_4basis_ten(tensor Jterm, tensor Kterm, tensor Lterm, tensor Mterm, tensor A0, tensor A1, tensor A2, tensor A3);
/* ../source/matrix.c */
matrix *create_matrix(int rows, int columns);
void attach_matrix(matrix *x, int rows, int columns, double *data);
matrix *destroy_matrix(matrix *x);
void check_matrix_index(matrix *x, int i, int j);
void check_invert(matrix *x);
void check_size(matrix *a, matrix *b);
void check_size_row(matrix *a, matrix *b);
void check_collapse_size(matrix *a, matrix *b);
void check_memory(matrix *x);
void check_add_shape(matrix *a, matrix *b);
void check_multiply_shape(matrix *a, matrix *b);
void check_multiply_size(matrix *a, matrix *b, matrix *x);
void check_invert_shape(matrix *a);
int get_num_columns(matrix *x);
int get_num_rows(matrix *x);
double *startof_matrix(matrix *x);
double *after_matrix(matrix *x);
void put_matrix_element(matrix *x, int i, int j, double value);
double get_matrix_element(matrix *x, int i, int j);
void put_block_matrix_element(matrix *x, int offset_i, int offset_j, int i, int j, double value);
double get_block_matrix_element(matrix *x, int offset_i, int offset_j, int i, int j);
void transpose_matrix(matrix *a, matrix *x);
void add_matrix(matrix *a, matrix *b, matrix *x);
void subtract_matrix(matrix *a, matrix *b, matrix *x);
void scale_matrix(double s, matrix *a, matrix *x);
void zero_last_matrix_row(matrix *a);
void fill_last_matrix_row(matrix *a, matrix *x);
void copy_matrix(matrix *a, matrix *x);
void multiply_matrix(matrix *a, matrix *b, matrix *x);
void multiply_element_row(matrix *a, matrix *b, int row_a, matrix *x);
void multiply_element_column(matrix *a, matrix *b, int row_a, int column_b, matrix *x);
void invert_matrix(matrix *a, matrix *x);
void invert_this_matrix(matrix *a);
void reduce_column(matrix *a, int col);
void reduce_row(matrix *a, int row, int pivot);
void scale_row(matrix *a, int row);
void show_matrix_info(matrix *x);
void show_matrix(matrix *x);
void show_matrix_1(matrix *x);
/* ../source/memory.c */
bem_vectors *create_bem_vectors(matrix *bvv, matrix *bcv, int N);
bem_vectors *destroy_bem_vectors(bem_vectors *x);
/* ../source/path.c */
path *create_path(int points, int make_xy, int make_value);
path *destroy_path(path *x);
void check_value_memory(path *p);
void check_xy_memory(path *p);
void check_path_index(path *p, int i);
void reverse_path(path *p);
void close_path(path *p);
void open_path(path *p);
double get_path_value(path *p, int i);
void get_path_xy(path *p, int i, coordinates xy);
void put_path_value(path *p, int i, double val);
void put_path_xy(path *p, int i, coordinates xy);
int num_points_in_path(path *p);
void show_path_info(path *p);
void show_path(path *p);
int path_length(unsigned char *file);
void get_path(unsigned char *file, path *p);
void plot_path(path *p, unsigned char *file);
/* ../source/path_list.c */
path_link *create_path_list(int n);
path_link *destroy_path_list(int n, path_link *path_list);
int search_path_list(unsigned char *file_name, int n, path_link *path_list);
int load_path_list(unsigned char *file_name, int index, path_link *path_list);
path *get_path_list(int index, path_link *path_list);
/* ../source/scan.c */
void put_raster(char *data, raster *ras);
void show_raster(raster *ras);
double x_raster(raster *ras, int i);
double y_raster(raster *ras, int j);
void put_section(char *data, section *sec);
void show_section(section *sec);
void xy_section(section *sec, int i, coordinates xy);
void put_interval(char *data, interval *inter);
void show_interval(interval *inter);
double t_interval(interval *inter, int i);
/* ../source/streamline.c */
int quadratic(double a[3], double z[2][2]);
int cubic(double a[4], double z[3][2]);
int quartic(double a[5], double z[4][2]);
int check_gv(int n, double v[4], double gv[4]);
double choose_max_or_min(int direction, double first[2], double second[2], double angle[4], int n, double r);
int myquartic(double *c, double *x);
int myquadratic(double *c, double *x);
void edit1_my_follow_stream(int direction, coordinates P, coordinates dV, tensor d2V, coordinates dP, double r);
double streamline_loop(coordinates P, catchment *c, int direction, int max_steps, double step_size, path *streamline, bem_vectors *vectors, bem_results *v1);
void plot_streamlines(catchment *c, int n_streams, path **streamlines, unsigned char *file);
void plot_streamlines_v2(catchment *c, int n_streams, path **streamlines, unsigned char *file);
void plot_1_streamline(catchment *c, path *streamline, FILE *output);
/* ../source/ten_matrix.c */
ten_matrix *create_ten_matrix(int rows, int columns);
void attach_ten_matrix(ten_matrix *x, int rows, int columns, tensor *data);
ten_matrix *destroy_ten_matrix(ten_matrix *x);
void check_ten_matrix_index(ten_matrix *x, int i, int j);
void check_ten_invert(ten_matrix *x);
void check_ten_memory(ten_matrix *x);
void check_ten_multiply_shape(ten_matrix *a, matrix *b);
void check_ten_multiply_size(ten_matrix *a, matrix *b, ten_matrix *x);
int get_ten_num_columns(ten_matrix *x);
int get_ten_num_rows(ten_matrix *x);
tensor *startof_ten_matrix(ten_matrix *x);
void put_ten_matrix_element(ten_matrix *x, int i, int j, tensor value);
void get_ten_matrix_element(ten_matrix *x, int i, int j, tensor value);
void put_block_ten_matrix_element(ten_matrix *x, int offset_i, int offset_j, int i, int j, tensor value);
void get_block_ten_matrix_element(ten_matrix *x, int offset_i, int offset_j, int i, int j, tensor value);
void multiply_ten_matrix(ten_matrix *a, matrix *b, ten_matrix *x);
void multiply_ten_element_row(ten_matrix *a, matrix *b, int row_a, ten_matrix *x);
void multiply_ten_element_column(ten_matrix *a, matrix *b, int row_a, int column_b, ten_matrix *x);
/* ../source/terms.c */
double Vterm_PonS(double x, double y1, double y2);
double Wterm_PonS(double x, double y1, double y2);
double Jterm_PonS(double x, double y1, double y2);
double Kterm_PonS(double x, double y1, double y2);
double Lterm_PonS(double x, double y1, double y2);
double Mterm_PonS(double x, double y1, double y2);
double Uj(double y1, double y2);
double Uk(double y1, double y2);
double Ul(double y1, double y2);
double Um(double y1, double y2);
double Vterm_PoffS(double x, double y1, double y2);
double Wterm_PoffS(double x, double y1, double y2);
double Jterm_PoffS(double x, double y1, double y2);
double Kterm_PoffS(double x, double y1, double y2);
double Lterm_PoffS(double x, double y1, double y2);
double Mterm_PoffS(double x, double y1, double y2);
double Tv(double x, double y1, double y2);
double Tw(double x, double y1, double y2);
double Tj(double x, double y1, double y2);
double Tk(double x, double y1, double y2);
double Tl(double x, double y1, double y2);
double Tm(double x, double y1, double y2);
void V1(double x, double y1, double y2, coordinates v);
void W1(double x, double y1, double y2, coordinates w);
void J1(double x, double y1, double y2, coordinates j);
void K1(double x, double y1, double y2, coordinates k);
void L1(double x, double y1, double y2, coordinates l);
void M1(double x, double y1, double y2, coordinates m);
double X1v(double x, double y1, double y2);
double Y1v(double x, double y1, double y2);
double X1w(double x, double y1, double y2);
double Y1w(double x, double y1, double y2);
double X1j(double x, double y1, double y2);
double Y1j(double x, double y1, double y2);
double X1k(double x, double y1, double y2);
double Y1k(double x, double y1, double y2);
double X1l(double x, double y1, double y2);
double Y1l(double x, double y1, double y2);
double X1m(double x, double y1, double y2);
double Y1m(double x, double y1, double y2);
void V2(double x, double y1, double y2, tensor v);
void W2(double x, double y1, double y2, tensor w);
void J2(double x, double y1, double y2, tensor j);
void K2(double x, double y1, double y2, tensor k);
void L2(double x, double y1, double y2, tensor l);
void M2(double x, double y1, double y2, tensor m);
double X2v(double x, double y1, double y2);
double Z2v(double x, double y1, double y2);
double X2w(double x, double y1, double y2);
double Z2w(double x, double y1, double y2);
double X2j(double x, double y1, double y2);
double Z2j(double x, double y1, double y2);
double X2k(double x, double y1, double y2);
double Z2k(double x, double y1, double y2);
double X2l(double x, double y1, double y2);
double Z2l(double x, double y1, double y2);
double X2m(double x, double y1, double y2);
double Z2m(double x, double y1, double y2);
/* ../source/trapfloat.c */
void trap_floating_errors(void);
/* ../source/vcalc.c */
double voltage_on_path(catchment *c, double s, int segment, path *this_path);
double voltage_outside_catchment(void);
double calculate_in_same_zone(boundary *b, coordinates P, bem_vectors *x, bem_results *R);
double calculate_in_new_zone(boundary *b, coordinates P, bem_vectors *x, bem_results *R);
double calculate_inside_catchment(catchment *c, coordinates P, bem_vectors *vectors, bem_results *voltage, int *new_z);
